using System;
using static GeneratorAPI.Generator;

namespace GeneratorAPI.Linq {
    public static partial class Extensions {
        /// <summary>
        ///     <para>
        ///         Projects each generation into a new form.
        ///     </para>
        /// </summary>
        /// <typeparam name="TSource">
        ///     The type of the elements of <paramref name="generator" />.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The type returned by selector.
        /// </typeparam>
        /// <param name="generator">
        ///     The <paramref name="generator" /> whose generations will invoke the transform function.
        /// </param>
        /// <param name="selector">A transform function to apply to each element.</param>
        /// <exception cref="ArgumentNullException">Argument <paramref name="generator" /> is null.</exception>
        /// <exception cref="ArgumentNullException">Argument <paramref name="selector" /> is null.</exception>
        /// <returns>
        ///     A <see cref="IGenerator{T}" /> whose elements are the result of invoking the transform function on each element
        ///     generated by
        ///     <paramref name="generator" />.
        /// </returns>
        /// <example>
        ///     <para>
        ///         Here's an example of transforming a string to int.
        ///         The result will be a generator which creates integers equal to the length of each first name generated.
        ///     </para>
        ///     <code language="c#">
        ///         IGenerator&lt;int&gt; = Factory.FirstName().Select((string x) => x.Length);
        ///     </code>
        /// </example>
        public static IGenerator<TResult> Select<TSource, TResult>(this IGenerator<TSource> generator,
            Func<TSource, TResult> selector) {
            if (selector == null) throw new ArgumentNullException(nameof(selector));
            if (generator == null) throw new ArgumentNullException(nameof(generator));
            return Function(() => selector(generator.Generate()));
        }

        /// <summary>
        ///     <para>
        ///         Projects each generation into a new form and includes a counter for the current generation.
        ///     </para>
        /// </summary>
        /// <typeparam name="TSource">
        ///     The type of the elements of <paramref name="generator" />.
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The type returned by selector.
        /// </typeparam>
        /// <param name="generator">
        ///     The <paramref name="generator" /> whose generations will invoke the transform function.
        /// </param>
        /// <param name="selector">
        ///     A transform function to apply to each source element; the second parameter of the
        ///     function represents a counter for the generation.
        /// </param>
        /// <exception cref="ArgumentNullException">Argument <paramref name="generator" /> is null.</exception>
        /// <exception cref="ArgumentNullException">Argument <paramref name="selector" /> is null.</exception>
        /// <returns>
        ///     A <see cref="IGenerator{T}" /> whose elements are the result of invoking the transform function on each element of
        ///     <paramref name="generator" />.
        /// </returns>
        /// <example>
        ///     <para>
        ///         Here's an example of transforming a string to int with a counter included.
        ///         The result will be a generator which creates integers equal to the length of each first name generated plus the current generation index.
        ///     </para>
        ///     <code language="c#">
        ///         IGenerator&lt;int&gt; transformedGenerator = Factory.FirstName().Select((string x, int y) => x.Length + y);
        ///     </code>
        /// </example>
        public static IGenerator<TResult> Select<TSource, TResult>(this IGenerator<TSource> generator,
            Func<TSource, int, TResult> selector) {
            var count = 0;
            return generator.Select(source => selector(source, count++));
        }
    }
}